studynum = clustervar,
data = dat[ A == FALSE, ],
userweights = 1 / (vi + t2hat.naive),
var.eff.size = vi,
small = small )
est.worst = as.numeric(meta.worst$b.r)
lo.worst = meta.worst$reg_table$CI.L
est.worst
lo.worst
q
eta.start = 1
a = 1
b = 500  # ~~ not sure what to use here...
lo.current = corrected_meta( yi = yi,
vi = vi,
eta = eta.start,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo
lo.current
eta.start
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo
lo.new
eta.current
a
b
# adjust the boundaries on where the
if (lo.new < q) b = eta.current
if (lo.new > q) a = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
eta.current = mean(c(a, b))
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo
lo.new
eta.current
a
b
# adjust the boundaries on where the
if (lo.new < q) b = eta.current
if (lo.new > q) a = eta.current
a
eta.current
b
lo.new
q
eta.start = 1
a = 1
b = 500  # ~~ not sure what to use here...
lo.current = corrected_meta( yi = yi,
vi = vi,
eta = eta.start,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo
lo.current
eta.start
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
eta.current = mean(c(a, b))
eta.current
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
a
b
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) b = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) a = eta.current
a
b
lo.new
eta.start = 1
a = 1
b = 500  # ~~ not sure what to use here...
lo.current = corrected_meta( yi = yi,
vi = vi,
eta = eta.start,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
while ( abs(lo.current - q) > 0.0005 &
abs(a - b) > 0.000001 ) {
# set the current guess for the s-value to the mean of the lower and upper bounds on
#  what it could be (a and b)
( eta.current = mean(c(a, b)) )
# get the corrected estimate for this candidate s-value, "eta.current"
# want est.new = q exactly
( lo.new = corrected_meta( yi = yi,
vi = vi,
eta = eta.current,
model = model,
clustervar = clustervar,
selection.tails = 1,
CI.level = CI.level,
small = small )$lo )
# adjust the search boundaries:
# if the CI limit now less than q (we overshot), eta needs to decrease below the current one
# so set upper bound to the current value
if (lo.new < q) a = eta.current
# if the CI limit still too large, eta needs to increase above the current one
# so set lower bound to the current value
if (lo.new > q) b = eta.current
a
b
}
a
b
55/60
.05/17
17+33
?p.adjust
p.adjust(p=c(0.05, .06), method="bonferroni")
p.adjust(p=c(0.05, .66), method="bonferroni")
sqrt(.35)
source('~/Dropbox/Personal computer/Independent studies/Sensitivity analysis for publication bias (SAPB)/Linked to OSF (SAPB)/R package PublicationBias/PublicationBias/R/functions.R')
?optimize
corrected_meta( yi = dO$yi,
vi = dO$vi,
eta = 1,
model = "robust" )$est
corrected_meta( yi = dO$yi,
vi = dO$vi,
eta = 1,
model = "robust" )$est
dO
sval.est
source('~/Dropbox/Personal computer/Independent studies/Sensitivity analysis for publication bias (SAPB)/Linked to OSF (SAPB)/R package PublicationBias/PublicationBias/R/functions.R')
source('~/Dropbox/Personal computer/Independent studies/Sensitivity analysis for publication bias (SAPB)/Linked to OSF (SAPB)/R package PublicationBias/PublicationBias/R/functions.R')
?svalue
source('~/Dropbox/Personal computer/Independent studies/Sensitivity analysis for publication bias (SAPB)/Linked to OSF (SAPB)/R package PublicationBias/PublicationBias/R/functions.R')
require(metafor)
dat = metafor::escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
##### Fixed-Effects Specification #####
# S-values and worst-case meta-analysis under fixed-effects specification
svals.FE.0 = svalue( yi = dat$yi,
vi = dat$vi,
q = 0,
model = "fixed" )
# publication bias required to shift point estimate to 0
svals.FE.0
library(dplyr)
require(metafor)
dat = metafor::escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
##### Fixed-Effects Specification #####
# S-values and worst-case meta-analysis under fixed-effects specification
svals.FE.0 = svalue( yi = dat$yi,
vi = dat$vi,
q = 0,
model = "fixed" )
# publication bias required to shift point estimate to 0
svals.FE.0
require(metafor)
dat = metafor::escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
##### Fixed-Effects Specification #####
# S-values and worst-case meta-analysis under fixed-effects specification
svals.FE.0 = svalue( yi = dat$yi,
vi = dat$vi,
q = 0,
model = "fixed" )
# publication bias required to shift point estimate to 0
svals.FE.0$sval.est
# now try shifting to a nonzero value (RR = 0.90)
svals.FE.q = svalue( yi = dat$yi,
vi = dat$vi,
q = log(.9),
model = "fixed" )
# publication bias required to shift point estimate to RR = 0.90
svals.FE.q$svals$sval.est
svals.FE.q$sval.est
library(devtools)
document()
build()
check()
document()
?svalue
check()
build()
?svalue
# calculate effect sizes from example dataset in metafor
require(metafor)
dat = metafor::escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
##### Fixed-Effects Specification #####
# S-values and worst-case meta-analysis under fixed-effects specification
svals.FE.0 = svalue( yi = dat$yi,
vi = dat$vi,
q = 0,
model = "fixed" )
# publication bias required to shift point estimate to 0
svals.FE.0$sval.est
# and to shift CI to include 0
svals.FE.0$sval.ci
# now try shifting to a nonzero value (RR = 0.90)
svals.FE.q = svalue( yi = dat$yi,
vi = dat$vi,
q = log(.9),
model = "fixed" )
# publication bias required to shift point estimate to RR = 0.90
svals.FE.q$sval.est
# and to shift CI to RR = 0.90
svals.FE.q$sval.ci
svalue( yi = dat$yi,
vi = dat$vi,
q = 0,
model = "robust" )
build()
check()
188000/24
?weightfunct
library(weightr)
?weightfunct
.547*75
75/7
372*.75
